<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Document</title>
</head>
<body>
	<div id=top> </div>
	<script>

		// Refactor LATER! Here is a copy-paste of my JS table:

		console.log('script says hiiii');
		document.body.style.cursor = 'default';
		cursorBox = [0,0]; // I know, keeping it simple atm
		for (let i = 0; i < 30; i++) {
			let mycol = document.createElement("div");
			mycol.style = "display:flex;";
			for (let j = 0; j < 30; j++) {
				let mydiv = document.createElement("div");
				// right then down the graphical convention
				mydiv.id = j.toString() + "," + i.toString();
				mydiv.style="height:20px;width:20px;background-color:rgb(0,0,0);"	
				mycol.append(mydiv);
			}
			document.getElementById('top').append(mycol);
		}



		// ~~~ AND HERE NOW IS THE INTERPRETER ~~~


		// glue connecting the two ~~~

		// x and y are logically indexed by 1, starting from bottom left,
		// first x across then y up. easy. This means tho some translations
		// to an index-by-zero system that is right then down
		let graphicalWrite = (x, y)  => {

			// XXX for now let's just be graceful if out of range
			if (x < 1 || x > 30) {
				return;
			}
			if (y < 1 || y > 30) {
				return;
			}

			// adjust for index convention
			x--;
			y--;

			// 30 magic
			y = 30 - y - 1;


			let mydiv = document.getElementById(x.toString() + "," + y.toString());
			// yes inelegant here we have to write out redundant style. Whatever
			// this will be in webgl later anyway
			mydiv.style="height:20px;width:20px;background-color:rgb(255,255,255);"
		}



		// SOURCE INSTRUCTION POINTER, i.e. which line are we on rn?
		let SIP = 0;

		let SKIP_SIP_INC = false;


		let GVARS = {};



		// yessss
		let l = (x) => {
			console.log(x);
		}

		// Guess what fools, all caps right now are used for certain big ass global
		// variables as I feel like it, some are constant, some are not!

		// valid binary op to bools
		let VALID_BOBS = ["!=", "=="];

		// oyy veyy, and now it begins
		let LD = -1; // LOOP-DEPTH. in first loop becomes 0 to point to *first* entry
		let loop_idxes = [];
		let loop_fail_spots = []; // run lengths
		let loop_start_incs = []; // +1 of the loop starts, where to loop back to

		// whether or not the if check is on, i.e. are we applying it?
		let ICON = true;


		// lets KISS that right now we only have ints legal in teh lang-lang.
		let getIntMeaning = (blah) => {

			// if it is in int format, job is easy
			let n = parseInt(blah);
			if (!isNaN(n)) {
				return n;
			}

			// hardwiring some magic next
			if (blah == "*idx*") {
				return loop_idxes[LD];
			}
			if (blah == "**idx**") {
				return loop_idxes[LD-1];
			}

			let maybsVal = GVARS[blah];
			if (maybsVal != undefined) {
				return maybsVal;
			}

		}



		// indexed from 0
		let getNthWord = (line, n) => {
			line = line.trimLeft();
			let words = line.split(' ');
			return words[n];
		}

		let getFirstWord = (line) => {
			return getNthWord(line, 0);
		}

		let performDataFunction = (line) => {

			// handle whitespace flab && comment lines
			if (line.length == 0) {
				l('Harmless lengthless line');
				SIP++;
				return;
	
			}
			if (line[0] == '/' && line[1] == '/') {
				l('Twas a comment!');
				SIP++;
				return;
			}



			let OP = getFirstWord(line)


			// with no icon, we skip over code, unless we find a FI which
			// tells us to switch back
			if (!ICON) {
				console.log('In the darkness, no icon!!!');
				if (OP == "fi") {
					ICON = true;
					l('Icon now set back to true, yayy!');
				}
				SIP++;
				return;
			}


			console.log('curIdx:', loop_idxes[LD]);
			console.log('failSpot:', loop_fail_spots[LD]);


			switch(OP) {

				case "fi": {
					ICON = true;
					console.log("FI", line);
					break;
				}

				case "lp": {
					console.log("LP", line);

					let start = parseInt(getNthWord(line, 1));
					let nruns = parseInt(getNthWord(line, 2));

					LD++;
					loop_idxes[LD] = start;
					// so if we loop start 2 for 5 runs, we go thru
					// 2,3,4,5,6 and then 7 is the spot of failure
					loop_fail_spots[LD] = start + nruns;

					loop_start_incs[LD] = SIP + 1;

					l(loop_idxes);
					l(loop_fail_spots);
					break;
				}


				case "if": {
					console.log("IF", line);

					// simple assumptions now for the win
					let arg1 = getNthWord(line, 1);
					let bob = getNthWord(line, 2); // bin op bool
					let arg2 = getNthWord(line, 3);


					if (!VALID_BOBS.includes(bob)) {
						console.log('FAIL, unsupported bob:', bob);
					}

					let arg1int = getIntMeaning(arg1);
					let arg2int = getIntMeaning(arg2);

					if (bob == "==") {
						ICON = (arg1int == arg2int);
						break;
					}
					if (bob == "!=") {
						ICON = (arg1int != arg2int);
						break;
					}

					break;
				}

				case "pl": {
					// one of TWO things can happen here:
					// 1) we continue and pop loop context
					// or
					// 2) we teleport to inc of loop start and inc counter
					console.log("PL", line);

					// if loop back

					let curIdx = loop_idxes[LD];
					let failSpot = loop_fail_spots[LD];



					// if we are now to move forward, loop time over
					if (curIdx >= failSpot-1) { // the -1 kind of a hack, loop counting
						// XXX above hack might cause failure in trivial loop cases
						//console.log("NOW:", curIdx, failSpot);
						loop_idxes.pop();
						loop_fail_spots.pop();
						LD--;
					} else {
						whereToLoopBackTo = loop_start_incs[LD];
						loop_idxes[LD]++;
						SIP = whereToLoopBackTo

						// yes, why ++ the loop start when we are already
						// doing a SIP++ anyway? I judge it's too slick and
						// pointlessly confusing.

						SKIP_SIP_INC = true;
					}

					break;
				}

				case "cp": {

					let shade = getNthWord(line, 1);

					let x = getIntMeaning("**idx**");
					let y = getIntMeaning("*idx*");

					console.log('Writing shade ', shade, 'to ', x, ',', y);

					graphicalWrite(x, y);
					



					break;
				}

				case "add": {

					// hey this nth word as 1 works well cuz the op is 0, score
					let arg1 = getIntMeaning(getNthWord(line, 1));
					let arg2 = getIntMeaning(getNthWord(line, 2));
					let dest_name = getNthWord(line, 3);

					let dest = arg1 + arg2;
					GVARS[dest_name] = dest;

				}


				default: {
					console.log("YA", line);
				}


			}			

			if (!SKIP_SIP_INC) {
				SIP++;
			}
			SKIP_SIP_INC = false;

		}
			


		let sauce = `
// Screen S starts out all 0, all black

lp 1 30
	lp 1 30
		if *idx* == **idx**
			cp #49 S>**idx**>*idx*
		fi
		add 2 **idx** firstvar
		if *idx* == firstvar
			cp #49 S>**idx**>*idx*
		fi
	pl
pl`

	

		l(`up and running`);
		l(sauce);




		sauceLines = sauce.split('\n');

		while (true) {
			if (SIP >= sauceLines.length || SIP < 0) {
				l("SIP has fallen off the map, maybs cuz program finished");
				break;

			}
			performDataFunction(sauceLines[SIP]);
		}




	</script>
</body>
</html>