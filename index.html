<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Document</title>
</head>
<body>
	<div id=top> </div>
	<script>

		Colors = {
			WHITE: 0,
			GOLD: 1,
			SILVER: 2,
			RED: 3,
			BLUE: 4,
		}

		// AND BOOM, ALL IN ONE FILE BABY, LET'S DEFINE THE BASIC SYNTAX HIGHLIGHTING
		// the problem should decompose for lang-lang into something line-by-line
		// Yes, the string is a list of characters, we want instead a list of colored
		// characters, redundancy of repeating red, red, red---who cares?!

		// in JS, say mystr[4] is a length-one string, that's fine for us. So we are
		// going to be returning a list of <length-one string, color enum> pairs.

		// Let's consider creating color objects mapped to strings. A multicolored
		// string, to deal with later, ... orr, you know maybe later we won't have any
		// contiguous (nowhitespace) string that would vary in syntax highlighting.
		// So let's forget that for now. 
		let color_liner = (line) => {
			let words = line.split(' ');

			// we'll build on this then deconstruct it in the output
			let bubbles = [];

			let op = words[0];
			switch (op) {
				// loop is always 3 words, loop start span
				case "loop": {
					bubbles.push({s: "loop", c: Colors.SILVER});
					let start = words[1];
					let span = words[2];

					if (!isNaN(parseInt(start))) {
						// we parsed an int, so a constant
						bubbles.push({s: start, c: Colors.WHITE});
					} else {
						// otherwise we have a variable
						bubbles.push({s: start, c: Colors.RED});
					}

					if (!isNaN(parseInt(span))) {
						// we parsed an int, so a constant
						bubbles.push({s: span, c: Colors.WHITE});
					} else {
						// otherwise we have a variable
						bubbles.push({s: span, c: Colors.RED});
					}

					break;

				}


				default: {
					console.log('Uh oh, unknown op for syntax highlighting');
				}
			}

			let output = [];
			for (let i = 0; i < bubbles.length; i++) {
				for (let j = 0; j < bubbles[i].s.length; j++) {
					output.push({s: bubbles[i].s[j], c: bubbles[i].c});
				}
				// now we have a space, a WHITE space
				output.push({s: " ", c: Colors.WHITE})
			}

			// last space was unnecessary
			output.pop();

			return output;


		}





		// Refactor LATER! Here is a copy-paste of my JS table:

		console.log('script says hiiii');
		document.body.style.cursor = 'default';
		cursorBox = [0,0]; // I know, keeping it simple atm
		for (let i = 0; i < 30; i++) {
			let mycol = document.createElement("div");
			mycol.style = "display:flex;";
			for (let j = 0; j < 30; j++) {
				let mydiv = document.createElement("div");
				// right then down the graphical convention
				mydiv.id = j.toString() + "," + i.toString();
				mydiv.style="height:20px;width:20px;background-color:rgb(0,0,0);"	
				mycol.append(mydiv);
			}
			document.getElementById('top').append(mycol);
		}



		// ~~~ AND HERE NOW IS THE INTERPRETER ~~~


		// glue connecting the two ~~~

		// x and y are logically indexed by 1, starting from bottom left,
		// first x across then y up. easy. This means tho some translations
		// to an index-by-zero system that is right then down

		// hehehe takes a shade from 0(black) to 49(white)
		let graphicalWrite = (x, y, shade)  => {

			// XXX for now let's just be graceful if out of range
			if (x < 1 || x > 30) {
				return;
			}
			if (y < 1 || y > 30) {
				return;
			}

			// adjust for index convention
			x--;
			y--;

			// 30 magic
			y = 30 - y - 1;

			// now for shade, we want 0->0 and 49->255 (heh, we may clip perfect white)
			let intensity = Math.floor(shade / 49 * 255);
			let color_string = "rgb(" + intensity.toString() + "," + 
				intensity.toString() + "," + intensity.toString() + ")";


			let mydiv = document.getElementById(x.toString() + "," + y.toString());
			// yes inelegant here we have to write out redundant style. Whatever
			// this will be in webgl later anyway
			mydiv.style="height:20px;width:20px;background-color:" + color_string + ";";
		}



		// SOURCE INSTRUCTION POINTER, i.e. which line are we on rn?
		let SIP = 0;

		let SKIP_SIP_INC = false;


		let GVARS = {};



		// yessss
		let l = (x) => {
			console.log(x);
		}

		// Guess what fools, all caps right now are used for certain big ass global
		// variables as I feel like it, some are constant, some are not!


		// oyy veyy, and now it begins
		let LD = -1; // LOOP-DEPTH. in first loop becomes 0 to point to *first* entry
		let loop_idxes = [];
		let loop_fail_spots = []; // run lengths
		let loop_start_incs = []; // +1 of the loop starts, where to loop back to

		// whether or not the if check is on, i.e. are we applying it?
		let ICON = true;


		// lets KISS that right now we only have ints legal in teh lang-lang.
		let getIntMeaning = (blah) => {

			// if it is in int format, job is easy
			let n = parseInt(blah);
			if (!isNaN(n)) {
				return n;
			}

			// hardwiring some magic next
			if (blah == "%1") {
				return loop_idxes[LD];
			}
			if (blah == "%2") {
				return loop_idxes[LD-1];
			}

			let maybsVal = GVARS[blah];
			if (maybsVal != undefined) {
				return maybsVal;
			}

		}



		// indexed from 0
		let getNthWord = (line, n) => {
			line = line.trimLeft();
			let words = line.split(' ');
			return words[n];
		}

		let getFirstWord = (line) => {
			return getNthWord(line, 0);
		}

		let performDataFunction = (line) => {

			// handle whitespace flab && comment lines
			if (line.length == 0) {
				l('Harmless lengthless line');
				SIP++;
				return;
	
			}
			if (line[0] == '/' && line[1] == '/') {
				l('Twas a comment!');
				SIP++;
				return;
			}



			let OP = getFirstWord(line)


			// with no icon, we skip over code, unless we find a FI which
			// tells us to switch back
			if (!ICON) {
				if (OP == "fi") {
					ICON = true;
				}
				SIP++;
				return;
			}


			switch(OP) {

				case "fi": {
					ICON = true;
					break;
				}

				case "loop": {
					let start = parseInt(getNthWord(line, 1));
					let nruns = parseInt(getNthWord(line, 2));

					LD++;
					loop_idxes[LD] = start;
					// so if we loop start 2 for 5 runs, we go thru
					// 2,3,4,5,6 and then 7 is the spot of failure
					loop_fail_spots[LD] = start + nruns;

					loop_start_incs[LD] = SIP + 1;

					break;
				}


				case "if": {
					// simple assumptions now for the win
					let arg1 = getNthWord(line, 1);
					let bob = getNthWord(line, 2); // bin op bool
					let arg2 = getNthWord(line, 3);


					let arg1int = getIntMeaning(arg1);
					let arg2int = getIntMeaning(arg2);

					if (bob == "==") {
						ICON = (arg1int == arg2int);
					} else if (bob == "!=") {
						ICON = (arg1int != arg2int);
					} else if (bob == "<") {
						ICON = (arg1int < arg2int);
					} else if (bob == ">") {
						ICON = (arg1int > arg2int);
					}

					break;
				}

				case "pool": {
					// one of TWO things can happen here:
					// 1) we continue and pop loop context
					// or
					// 2) we teleport to inc of loop start and inc counter

					let curIdx = loop_idxes[LD];
					let failSpot = loop_fail_spots[LD];

					// if we are now to move forward, loop time over
					if (curIdx >= failSpot-1) { // the -1 kind of a hack, loop counting
						// XXX above hack might cause failure in trivial loop cases
						//console.log("NOW:", curIdx, failSpot);
						loop_idxes.pop();
						loop_fail_spots.pop();
						LD--;
					} else {
						whereToLoopBackTo = loop_start_incs[LD];
						loop_idxes[LD]++;
						SIP = whereToLoopBackTo

						// yes, why ++ the loop start when we are already
						// doing a SIP++ anyway? I judge it's too slick and
						// pointlessly confusing.

						SKIP_SIP_INC = true;
					}

					break;
				}

				// XXX Hacks still cheating
				case "cp": {

					let shade = getIntMeaning(getNthWord(line, 1));

					let x = getIntMeaning("%2");
					let y = getIntMeaning("%1");

					graphicalWrite(x, y, shade);
					



					break;
				}

				case "add": {

					// hey this nth word as 1 works well cuz the op is 0, score
					let arg1 = getIntMeaning(getNthWord(line, 1));
					let arg2 = getIntMeaning(getNthWord(line, 2));
					let dest_name = getNthWord(line, 3);

					GVARS[dest_name] = arg1 + arg2;

					break;

				}

				case "sub": {

					let arg1 = getIntMeaning(getNthWord(line, 1));
					let arg2 = getIntMeaning(getNthWord(line, 2));
					let dest_name = getNthWord(line, 3);

					// MWAHAHAHA subtract first arg from second arg
					let dest = arg2 - arg1;
					GVARS[dest_name] = dest;

					break;

				}

				case "rngi": {

					let arg1 = getIntMeaning(getNthWord(line, 1));
					let dest_name = getNthWord(line, 2);
					// + 1 for index by 1
					GVARS[dest_name] = Math.floor(Math.random()*arg1) + 1;


					break;
				}


				default: {
					console.log("Unsupported op:", line);
				}


			}			

			if (!SKIP_SIP_INC) {
				SIP++;
			}
			SKIP_SIP_INC = false;

		}
			


		let sauce = `
// Screen S starts out all 0, all black

loop 1 30
	loop 1 30
		rngi 50 myrand
		if myrand < 20
			add 20 myrand myrand
		fi
		sub 1 %2 var1
		if %1 == var1
			cp myrand S>%2>%1
		fi
		add 1 %2 var2
		if %1 == var2
			cp myrand S>%2>%1
		fi
	pool
pool`

	

		l(`up and running`);
		l(sauce);




		sauceLines = sauce.split('\n');

		while (true) {
			if (SIP >= sauceLines.length || SIP < 0) {
				l("SIP has fallen off the map, maybs cuz program finished");
				break;

			}
			performDataFunction(sauceLines[SIP]);
		}




	</script>
</body>
</html>